library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;

library mylib;

entity ClockMonitor is
  port
  (
    modClockIn  : in std_logic; -- Modulated clock. It is monitored.
    clkIndep    : in std_logic; -- Monitors modClockIn. Must be generated by an independent clock source from CDCM.
                                -- Recommendation: use refclk for IDELAYCTRL.
    clockLost   : out std_logic -- Indicates modClockIn is lost. (active high)
  );
end ClockMonitor;

architecture RTL of ClockMonitor is
  constant kCheckIndex  : integer:= 5;
  constant kThreshold   : integer:= 950;

  signal sample         : std_logic_vector(2 downto 0);
  signal counter_a, counter_b   : std_logic_vector(kCheckIndex downto 0);

  signal reset_counter          : std_logic;
  signal detect_clock, time_out : std_logic;

  attribute async_reg   : string;
  attribute async_reg   of u_sync : label is "true";

begin
  -- ======================================================================
  --                                 body
  -- ======================================================================

  u_sync : process(clkIndep)
  begin
    if(clkIndep'event and clkIndep = '1') then
      sample(0)   <= modClockIn;
      sample(1)   <= sample(0);
      sample(2)   <= sample(1);
    end if;
  end process;

  reset_counter   <= sample(2);

  u_counter_a : process(clkIndep)
  begin
    if(clkIndep'event and clkIndep = '1') then
      if(reset_counter = '0') then
        counter_a   <= (others => '0');
      else
        counter_a   <= std_logic_vector(unsigned(counter_a) + 1);
      end if;
    end if;
  end process;

  u_counter_b : process(clkIndep)
  begin
    if(clkIndep'event and clkIndep = '1') then
      if(reset_counter = '1') then
        counter_b   <= (others => '0');
      else
        counter_b   <= std_logic_vector(unsigned(counter_b) + 1);
      end if;
    end if;
  end process;

  u_timeout   : process(clkIndep)
  begin
    if(clkIndep'event and clkIndep = '1') then
      if(counter_a(kCheckIndex) = '1' or counter_b(kCheckIndex) = '1') then
        time_out  <= '1';
      else
        time_out  <= '0';
      end if;
    end if;
  end process;

  u_lost_monitor : process(clkIndep)
    variable  monitor_count : integer range 0 to 1023:= 0;
  begin
    if(clkIndep'event and clkIndep = '1') then
      if(time_out = '1') then
        detect_clock    <= '0';
        monitor_count   := 0;
      elsif(monitor_count = kThreshold) then
        detect_clock    <= '1';
      else
        detect_clock    <= '0';
        monitor_count   := monitor_count +1;
      end if;

      clockLost <= not detect_clock;
    end if;
  end process;

end RTL;
